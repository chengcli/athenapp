diff --git a/src/bvals/bvals_var.cpp b/src/bvals/bvals_var.cpp
index 6d2460f1..a432e2a8 100644
--- a/src/bvals/bvals_var.cpp
+++ b/src/bvals/bvals_var.cpp
@@ -22,6 +22,8 @@
 #include "../mesh/mesh.hpp"
 #include "bvals_interfaces.hpp"
 
+#include "../cubed_sphere.hpp"
+
 // MPI header
 #ifdef MPI_PARALLEL
 #include <mpi.h>
@@ -211,6 +213,61 @@ void BoundaryVariable::SetCompletedFlagSameProcess(NeighborBlock& nb) {
 
 void BoundaryVariable::SendBoundaryBuffers() {
   MeshBlock *pmb = pmy_block_;
+#ifdef CUBED_SPHERE
+  // For cubed sphere, synchronize the in-panel boundary buffers first
+  // In cubed sphere option, MPI is automatically enabled and each process only allow one block
+  LogicalLocation loc = pmb->loc;
+  for (int n=0; n<pbval_->nneighbor; n++) {
+    NeighborBlock& nb = pbval_->neighbor[n];
+    int ox2 = nb.ni.ox2;
+    int ox3 = nb.ni.ox3;
+    int tox2, tox3;
+    TransformOxForCubedSphere(&ox2, &ox3, &tox2, &tox3, loc);
+    LogicalLocation tloc;
+    tloc.lx1 = loc.lx1;
+    tloc.lx2 = loc.lx2 + ox2;
+    tloc.lx3 = loc.lx3 + ox3;
+    int blockID_tg = FindBlockID(tloc);
+    int blockID = FindBlockID(loc);
+    if (blockID != blockID_tg) // Not in the same panel
+      continue;
+    if (bd_var_.sflag[nb.bufid] == BoundaryStatus::completed) continue;
+    int ssize;
+    ssize = LoadBoundaryBufferSameLevel(bd_var_.send[nb.bufid], nb); // Cubed sphere only has same-level neighbors
+    MPI_Start(&(bd_var_.req_send[nb.bufid]));
+    bd_var_.sflag[nb.bufid] = BoundaryStatus::completed;
+  }
+
+  // Receive the in-panel boundary buffers
+  // Note that the BoudaryStatus flag is set to "waiting" before this is called
+  for (int n=0; n<pbval_->nneighbor; n++) {
+    NeighborBlock& nb = pbval_->neighbor[n];
+    int ox2 = nb.ni.ox2;
+    int ox3 = nb.ni.ox3;
+    int tox2, tox3;
+    TransformOxForCubedSphere(&ox2, &ox3, &tox2, &tox3, loc);
+    LogicalLocation tloc;
+    tloc.lx1 = loc.lx1;
+    tloc.lx2 = loc.lx2 + ox2;
+    tloc.lx3 = loc.lx3 + ox3;
+    int blockID_tg = FindBlockID(tloc);
+    int blockID = FindBlockID(loc);
+    if (blockID != blockID_tg) // Not in the same panel
+      continue;
+    if (bd_var_.flag[nb.bufid] == BoundaryStatus::arrived) continue;
+    while (bd_var_.flag[nb.bufid] == BoundaryStatus::waiting) {
+        int test;
+        // probe MPI communications.  This is a bit of black magic that seems to promote
+        // communications to top of stack and gets them to complete more quickly
+        MPI_Iprobe(MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, &test, MPI_STATUS_IGNORE);
+        MPI_Test(&(bd_var_.req_recv[nb.bufid]), &test, MPI_STATUS_IGNORE);
+        if (!static_cast<bool>(test)) {
+          continue;
+        }
+        bd_var_.flag[nb.bufid] = BoundaryStatus::arrived;
+    }
+  }
+#endif
   int mylevel = pmb->loc.level;
   for (int n=0; n<pbval_->nneighbor; n++) {
     NeighborBlock& nb = pbval_->neighbor[n];
diff --git a/src/bvals/cc/bvals_cc.cpp b/src/bvals/cc/bvals_cc.cpp
index c923ef1f..9f60ddff 100644
--- a/src/bvals/cc/bvals_cc.cpp
+++ b/src/bvals/cc/bvals_cc.cpp
@@ -30,6 +30,7 @@
 #include "../../utils/buffer_utils.hpp"
 #include "../bvals.hpp"
 #include "bvals_cc.hpp"
+#include "../../cubed_sphere.hpp"
 
 // MPI header
 #ifdef MPI_PARALLEL
@@ -211,7 +212,12 @@ int CellCenteredBoundaryVariable::LoadBoundaryBufferSameLevel(Real *buf,
   ek = (nb.ni.ox3 < 0) ? (pmb->ks + NGHOST - 1) : pmb->ke;
   int p = 0;
   AthenaArray<Real> &var = *var_cc;
+#ifdef CUBED_SPHERE
+// nl_, nu_, after buf var
+  PackDataCubedSphere(var, buf, nl_, nu_, si, ei, sj, ej, sk, ek, p, nb.ni.ox1, nb.ni.ox2, nb.ni.ox3, pmb->loc);
+#else
   BufferUtility::PackData(var, buf, nl_, nu_, si, ei, sj, ej, sk, ek, p);
+#endif
   return p;
 }
 
diff --git a/src/coordinates/coordinates.cpp b/src/coordinates/coordinates.cpp
index 9baa4f78..418ee51c 100644
--- a/src/coordinates/coordinates.cpp
+++ b/src/coordinates/coordinates.cpp
@@ -19,6 +19,8 @@
 #include "../mesh/mesh.hpp"
 #include "../parameter_input.hpp"
 #include "coordinates.hpp"
+#include "../cubed_sphere.hpp"
+
 
 //----------------------------------------------------------------------------------------
 //! Coordinates constructor: sets coordinates and coordinate spacing of cell FACES
@@ -207,10 +209,18 @@ Coordinates::Coordinates(MeshBlock *pmb, ParameterInput *pin, bool flag) :
           noffset = static_cast<std::int64_t>((j-jl)*2 + lx2*block_size.nx2);
         }
         Real rx = ComputeMeshGeneratorX(noffset, nrootmesh, true);
+#ifdef CUBED_SPHERE
+        x2f(j) = CubedSphereMeshGeneratorX2(rx, pmy_block->loc);
+#else
         x2f(j) = pm->MeshGenerator_[X2DIR](rx, mesh_size);
+#endif
       }
+#ifdef CUBED_SPHERE
+      // Do nothing
+#else
       x2f(jl) = block_size.x2min;
       x2f(ju+1) = block_size.x2max;
+#endif
 
       for (int j=jl-ng; j<=ju+ng; ++j) {
         dx2f(j) = dx;
@@ -288,10 +298,18 @@ Coordinates::Coordinates(MeshBlock *pmb, ParameterInput *pin, bool flag) :
           noffset = static_cast<std::int64_t>((k-kl)*2 + lx3*block_size.nx3);
         }
         Real rx = ComputeMeshGeneratorX(noffset, nrootmesh, true);
+#ifdef CUBED_SPHERE
+        x3f(k) = CubedSphereMeshGeneratorX3(rx, pmy_block->loc);
+#else
         x3f(k) = pm->MeshGenerator_[X3DIR](rx, mesh_size);
+#endif
       }
+#ifdef CUBED_SPHERE
+      // Do nothing
+#else
       x3f(kl) = block_size.x3min;
       x3f(ku+1) = block_size.x3max;
+#endif
 
       for (int k=kl-ng; k<=ku+ng; ++k) {
         dx3f(k) = dx;
diff --git a/src/cubed_sphere.hpp b/src/cubed_sphere.hpp
new file mode 100644
index 00000000..cd9b8a68
--- /dev/null
+++ b/src/cubed_sphere.hpp
@@ -0,0 +1,216 @@
+#ifndef CUBED_SPHERE_HPP
+#define CUBED_SPHERE_HPP
+#include "athena.hpp"
+#include "coordinates/coordinates.hpp"
+
+int FindBlockID(LogicalLocation const& loc);
+
+void TransformOxForCubedSphere(int *ox2, int *ox3, int *tox2, int *tox3,
+  LogicalLocation const& loc);
+
+void PackDataCubedSphere(const AthenaArray<Real> &src, Real *buf,
+         int sn, int en, int si, int ei, int sj, int ej, int sk, int ek, int &offset,
+         int ox1, int ox2, int ox3,LogicalLocation const& loc);
+
+void ProjectLocalCartesianAffine(const AthenaArray<Real> &src, 
+        AthenaArray<Real> &tgt, Real affine_angle, int sn, int en, int si, int ei, int sj, 
+        int ej, int sk, int ek, int Dir);
+
+void DeProjectLocalCartesianAffine(AthenaArray<Real> &flux, 
+        Real affine_angle, int sn, int en, int si, int ei, int sj, int ej, int sk, int ek, int Dir);
+
+Real CubedSphereMeshGeneratorX2(Real x, LogicalLocation const& loc);
+Real CubedSphereMeshGeneratorX3(Real x, LogicalLocation const& loc);
+
+
+// Helper functions
+void GetLatLon(Real *lat, Real *lon, Coordinates *pcoord, int k, int j, int i);
+void GetLatLonFace2(Real *lat, Real *lon, Coordinates *pcoord, int k, int j, int i);
+void GetLatLonFace3(Real *lat, Real *lon, Coordinates *pcoord, int k, int j, int i);
+
+void GetUV(Real *U, Real *V, Coordinates *pcoord, Real V2, Real V3, int k, int j, int i);
+void GetVyVz(Real *V2, Real *V3, Coordinates *pcoord, Real U, Real V, int k, int j, int i);
+// Helper functions adapted from Paul
+void VecTransABPFromRLL(
+	Real X,
+	Real Y,
+	int blockID,
+	Real U,
+	Real V,
+	Real *V2,
+	Real *V3
+);
+void VecTransRLLFromABP(
+	Real X,
+	Real Y,
+	int blockID,
+	Real V2,
+	Real V3,
+	Real *U,
+	Real *V
+);
+void RLLFromXYP(
+	Real dX,
+	Real dY,
+	int nP,
+	Real &lon,
+	Real &lat
+);
+void XYPFromRLL(
+	Real lon,
+	Real lat,
+	Real &dX,
+	Real &dY,
+	int &nP
+);
+
+class GnomonicEquiangle : public Coordinates {
+public:
+  GnomonicEquiangle(MeshBlock *pmb, ParameterInput *pin, bool flag);
+  void Face1Area(const int k, const int j, const int il, const int iu,
+                 AthenaArray<Real> &area) final;
+  void Face2Area(const int k, const int j, const int il, const int iu,
+                 AthenaArray<Real> &area) final;
+  void Face3Area(const int k, const int j, const int il, const int iu,
+                 AthenaArray<Real> &area) final;
+
+  Real GetFace1Area(const int k, const int j, const int i) final;
+  Real GetFace2Area(const int k, const int j, const int i) final;
+  Real GetFace3Area(const int k, const int j, const int i) final;
+
+  Real GetVolCenterFace1Area(const int k, const int j, const int i);
+  Real GetVolCenterFace2Area(const int k, const int j, const int i);
+  Real GetVolCenterFace3Area(const int k, const int j, const int i);
+
+  void VolCenterFace1Area(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &area) final;
+  void VolCenterFace2Area(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &area) final;
+  void VolCenterFace3Area(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &area) final;
+  void CellVolume(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &vol);
+  Real GetCellVolume(const int k, const int j, const int i);
+
+  void CenterWidth1(const int k, const int j, const int il, const int iu,
+                                AthenaArray<Real> &dx1);
+  void CenterWidth2(const int k, const int j, const int il, const int iu,
+                                AthenaArray<Real> &dx2);
+  void CenterWidth3(const int k, const int j, const int il, const int iu,
+                                AthenaArray<Real> &dx3);
+
+  void CellMetric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+  void Face1Metric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+  void Face2Metric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+  void Face3Metric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+
+
+  void PrimToLocal2(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &b1_vals, AthenaArray<Real> &prim_left,
+        AthenaArray<Real> &prim_right, AthenaArray<Real> &bx);
+  void PrimToLocal3(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &b1_vals, AthenaArray<Real> &prim_left,
+        AthenaArray<Real> &prim_right, AthenaArray<Real> &bx);
+
+  void FluxToGlobal2(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &cons, const AthenaArray<Real> &bbx,
+        AthenaArray<Real> &flux, AthenaArray<Real> &ey, AthenaArray<Real> &ez);
+  void FluxToGlobal3(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &cons, const AthenaArray<Real> &bbx,
+        AthenaArray<Real> &flux, AthenaArray<Real> &ey, AthenaArray<Real> &ez);
+  void AddCoordTermsDivergence(
+    const Real dt, const AthenaArray<Real> *flux,
+    const AthenaArray<Real> &prim, const AthenaArray<Real> &bcc, AthenaArray<Real> &u);
+
+
+  void Edge1Length(const int k, const int j, const int il, const int iu,
+      AthenaArray<Real> &len);
+  void Edge2Length(const int k, const int j, const int il, const int iu,
+      AthenaArray<Real> &len);
+  void Edge3Length(const int k, const int j, const int il, const int iu,
+      AthenaArray<Real> &len);
+  void VolCenter1Length(const int k, const int j, const int il, const int iu,
+      AthenaArray<Real> &len);
+  void VolCenter2Length(const int k, const int j, const int il, const int iu,
+      AthenaArray<Real> &len);
+  void VolCenter3Length(const int k, const int j, const int il, const int iu,
+      AthenaArray<Real> &len);
+  Real GetEdge1Length(const int k, const int j, const int i);
+  Real GetEdge2Length(const int k, const int j, const int i);
+  Real GetEdge3Length(const int k, const int j, const int i);
+
+};
+
+class AffineCoordinate : public Coordinates {
+public:
+  AffineCoordinate(MeshBlock *pmb, ParameterInput *pin, bool flag);
+
+  void Face1Area(const int k, const int j, const int il, const int iu,
+                 AthenaArray<Real> &area) final;
+  void Face2Area(const int k, const int j, const int il, const int iu,
+                 AthenaArray<Real> &area) final;
+  void Face3Area(const int k, const int j, const int il, const int iu,
+                 AthenaArray<Real> &area) final;
+  Real GetFace1Area(const int k, const int j, const int i) final;
+  Real GetFace2Area(const int k, const int j, const int i) final;
+  Real GetFace3Area(const int k, const int j, const int i) final;
+
+  void VolCenterFace1Area(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &area) final;
+  void VolCenterFace2Area(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &area) final;
+  void VolCenterFace3Area(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &area) final;
+  void CellVolume(const int k, const int j, const int il, const int iu,
+                          AthenaArray<Real> &vol);
+  Real GetCellVolume(const int k, const int j, const int i);
+
+  void CellMetric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+  void Face1Metric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+  void Face2Metric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+  void Face3Metric(const int k, const int j, const int il, const int iu, AthenaArray<Real> &g, AthenaArray<Real> &g_inv);
+
+
+  void PrimToLocal2(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &b1_vals, AthenaArray<Real> &prim_left,
+        AthenaArray<Real> &prim_right, AthenaArray<Real> &bx);
+  void PrimToLocal3(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &b1_vals, AthenaArray<Real> &prim_left,
+        AthenaArray<Real> &prim_right, AthenaArray<Real> &bx);
+
+  void FluxToGlobal2(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &cons, const AthenaArray<Real> &bbx,
+        AthenaArray<Real> &flux, AthenaArray<Real> &ey, AthenaArray<Real> &ez);
+  void FluxToGlobal3(
+        const int k, const int j, const int il, const int iu,
+        const AthenaArray<Real> &cons, const AthenaArray<Real> &bbx,
+        AthenaArray<Real> &flux, AthenaArray<Real> &ey, AthenaArray<Real> &ez);
+protected:
+  Real theta_;
+  Real sin_theta_;
+  Real cos_theta_;
+};
+
+class CubedSphereLR{
+  public:
+    void SetMeshBlock(MeshBlock *pmb_in);
+    void InitializeSizes(int nc3, int nc2, int nc1);
+    void SaveLR3DValues(AthenaArray<Real> &L_in, AthenaArray<Real> &R_in, int direction, int k, int j, int il, int iu);
+    void LoadLR3DValues(AthenaArray<Real> &L_in, AthenaArray<Real> &R_in, int direction, int k, int j, int il, int iu);
+    void SynchronizeFluxes();
+    void SendNeighborBlocks(LogicalLocation const& loc, int ox2, int ox3, int tg_rank, int tg_gid);
+    void RecvNeighborBlocks(LogicalLocation const& loc, int ox2, int ox3, int tg_rank, int tg_gid);
+
+    AthenaArray<Real> L3DValues, R3DValues;
+    MeshBlock *pmb;
+};
+
+#endif
+
diff --git a/src/eos/adiabatic_hydro.cpp b/src/eos/adiabatic_hydro.cpp
index e61ff205..ed8fe4d1 100644
--- a/src/eos/adiabatic_hydro.cpp
+++ b/src/eos/adiabatic_hydro.cpp
@@ -19,6 +19,7 @@
 #include "../mesh/mesh.hpp"
 #include "../parameter_input.hpp"
 #include "eos.hpp"
+#include "../cubed_sphere.hpp"
 
 // EquationOfState constructor
 
@@ -67,7 +68,16 @@ void EquationOfState::ConservedToPrimitive(
         w_vy = u_m2*di;
         w_vz = u_m3*di;
 
-        Real e_k = 0.5*di*(SQR(u_m1) + SQR(u_m2) + SQR(u_m3));
+        Real e_k;
+#ifdef CUBED_SPHERE
+        Real U, V;
+        // Convert m2 m3 to lat-lon
+        GetUV(&U, &V, pco, u_m2, u_m3, k, j, i);
+        e_k = 0.5*di*(SQR(u_m1) + SQR(U) + SQR(V));
+#else
+        e_k = 0.5*di*(SQR(u_m1) + SQR(u_m2) + SQR(u_m3));
+#endif
+
         w_p = gm1*(u_e - e_k);
 
         // apply pressure floor, correct total energy
@@ -107,11 +117,18 @@ void EquationOfState::PrimitiveToConserved(
         const Real& w_vz = prim(IVZ,k,j,i);
         const Real& w_p  = prim(IPR,k,j,i);
 
+#ifdef CUBED_SPHERE
+        Real U, V;
+        // Convert vy vz to lat-lon
+        GetUV(&U, &V, pco, w_vy, w_vz, k, j, i);
+        u_e = w_p*igm1 + 0.5*w_d*(SQR(w_vx) + SQR(U) + SQR(V));
+#else
+        u_e = w_p*igm1 + 0.5*w_d*(SQR(w_vx) + SQR(w_vy) + SQR(w_vz));
+#endif
         u_d = w_d;
         u_m1 = w_vx*w_d;
         u_m2 = w_vy*w_d;
         u_m3 = w_vz*w_d;
-        u_e = w_p*igm1 + 0.5*w_d*(SQR(w_vx) + SQR(w_vy) + SQR(w_vz));
       }
     }
   }
diff --git a/src/hydro/hydro.cpp b/src/hydro/hydro.cpp
index 4f52b6c3..4de825f0 100644
--- a/src/hydro/hydro.cpp
+++ b/src/hydro/hydro.cpp
@@ -144,6 +144,17 @@ Hydro::Hydro(MeshBlock *pmb, ParameterInput *pin) :
     laplacian_r_fc_.NewAthenaArray(nc1);
   }
 
+#ifdef CUBED_SPHERE
+  // initialize 3D values
+  L3DValues[0].NewAthenaArray(NWAVE, nc3, nc2, nc1);
+  L3DValues[1].NewAthenaArray(NWAVE, nc3, nc2, nc1);
+  L3DValues[2].NewAthenaArray(NWAVE, nc3, nc2, nc1);
+
+  R3DValues[0].NewAthenaArray(NWAVE, nc3, nc2, nc1);
+  R3DValues[1].NewAthenaArray(NWAVE, nc3, nc2, nc1);
+  R3DValues[2].NewAthenaArray(NWAVE, nc3, nc2, nc1);
+#endif
+
   UserTimeStep_ = pmb->pmy_mesh->UserTimeStep_;
 }
 
diff --git a/src/hydro/hydro.hpp b/src/hydro/hydro.hpp
index 73723794..b610d89c 100644
--- a/src/hydro/hydro.hpp
+++ b/src/hydro/hydro.hpp
@@ -50,6 +50,13 @@ class Hydro {
 
   AthenaArray<Real> flux[3];  // face-averaged flux vector
 
+#ifdef CUBED_SPHERE
+  AthenaArray<Real> L3DValues[3], R3DValues[3];
+  MPI_Request send_request[4];
+  MPI_Request recv_request[4];
+  std::vector<Real> LRDataBuffer[4];
+#endif
+
   // storage for SMR/AMR
   // TODO(KGF): remove trailing underscore or revert to private:
   AthenaArray<Real> coarse_cons_, coarse_prim_;
@@ -89,6 +96,19 @@ class Hydro {
   void CalculateVelocityDifferences(const int k, const int j, const int il, const int iu,
     const int ivx, AthenaArray<Real> &dvn, AthenaArray<Real> &dvt);
 
+#ifdef CUBED_SPHERE
+  void SaveLR3DValues(AthenaArray<Real> &L_in, AthenaArray<Real> &R_in,
+    int direction, int k, int j, int il, int iu);
+
+  void LoadLR3DValues(AthenaArray<Real> &L_in, AthenaArray<Real> &R_in,
+    int direction, int k, int j, int il, int iu);
+
+  void SynchronizeFluxesSend();
+  void SynchronizeFluxesRecv();
+  void SendNeighborBlocks(LogicalLocation const& loc, int ox2, int ox3, int tg_rank, int tg_gid);
+  void RecvNeighborBlocks(LogicalLocation const& loc, int ox2, int ox3, int tg_rank, int tg_gid);
+#endif
+
  private:
   AthenaArray<Real> dt1_, dt2_, dt3_;  // scratch arrays used in NewTimeStep
   // scratch space used to compute fluxes
diff --git a/src/mesh/meshblock.cpp b/src/mesh/meshblock.cpp
index 60313566..f924c7d5 100644
--- a/src/mesh/meshblock.cpp
+++ b/src/mesh/meshblock.cpp
@@ -24,6 +24,7 @@
 #include "../athena_arrays.hpp"
 #include "../bvals/bvals.hpp"
 #include "../coordinates/coordinates.hpp"
+#include "../cubed_sphere.hpp"
 #include "../eos/eos.hpp"
 #include "../fft/athena_fft.hpp"
 #include "../field/field.hpp"
@@ -116,8 +117,11 @@ MeshBlock::MeshBlock(int igid, int ilid, LogicalLocation iloc, RegionSize input_
     pcoord = new KerrSchild(this, pin, false);
   } else if (std::strcmp(COORDINATE_SYSTEM, "gr_user") == 0) {
     pcoord = new GRUser(this, pin, false);
+  } else if (std::strcmp(COORDINATE_SYSTEM, "gnomonic_equiangle") == 0) {
+    pcoord = new GnomonicEquiangle(this, pin, false);
+  } else if (std::strcmp(COORDINATE_SYSTEM, "affine_coordinates") == 0) {
+    pcoord = new AffineCoordinate(this, pin, false);
   }
-
   // Reconstruction: constructor may implicitly depend on Coordinates, and PPM variable
   // floors depend on EOS, but EOS isn't needed in Reconstruction constructor-> this is ok
   precon = new Reconstruction(this, pin);
